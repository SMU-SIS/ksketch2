<?xml version="1.0" encoding="utf-8"?>
<!--
*Copyright 2010-2012 Singapore Management University
*Developed under a grant from the Singapore-MIT GAMBIT Game Lab

*This Source Code Form is subject to the terms of the
*Mozilla Public License, v. 2.0. If a copy of the MPL was
*not distributed with this file, You can obtain one at
*http://mozilla.org/MPL/2.0/.
-->
<s:SkinnablePopUpContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
						   xmlns:s="library://ns.adobe.com/flex/spark"
						   backgroundAlpha="0"
						   creationComplete="_initButtons()"
						   updateComplete="updateMenuDisplay()"
						   xmlns:buttons="sg.edu.smu.ksketch2.canvas.components.buttons.*">
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import mx.formatters.DateFormatter;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			
			import sg.edu.smu.ksketch2.KSketch2;
			import sg.edu.smu.ksketch2.KSketchAssets;
			import sg.edu.smu.ksketch2.KSketchStyles;
			import sg.edu.smu.ksketch2.canvas.components.view.KSketch_CanvasView;
			import sg.edu.smu.ksketch2.canvas.controls.KFileControl;
			import sg.edu.smu.ksketch2.canvas.controls.KInteractionControl;
			import sg.edu.smu.ksketch2.canvas.controls.interactors.KCanvasInteractorManager;
			import sg.edu.smu.ksketch2.canvas.controls.interactors.KMultiTouchDrawInteractor;
			import sg.edu.smu.ksketch2.canvas.controls.interactors.draw.KDrawInteractor;
			import sg.edu.smu.ksketch2.utils.KWebData;
			
			public static const ORIGIN:Point = new Point();
			public static const LEFT:int = 0;
			public static const RIGHT:int = 1;
			public static const UP:int = 2;
			public static const DOWN:int = 3;
			public static const TAPANYWHERE:int = 0;
			public static const TAPOBJECT:int = 1;
			
			//Positioning variables
			private var _referenceComponent:UIComponent;
			private var _canvasOrigin:Point = new Point();
			private var _position:int;
			
			private var dataSource:IDataInput;
			
			//Current pen button that has been toggled
			private var _selectedButton:KSketch_Toggle_Button;
			
			private var _canvasView:KSketch_CanvasView;
			private var _options:KSketch_Options;
			private var _instructionsBox:KSketch_InstructionsBox;
			private var _help:KSketch_Help;
			private var _saveOptions:KSketch_SaveOptions;
			private var _feedback:KSketch_Feedback_Message;
			
			private var _KSketch:KSketch2;
			private var _interactionControl:KInteractionControl;
			private var _canvasControl:KCanvasInteractorManager;
			
			//KSKETCH-SYNPHNE
			private const TIMER_INTERVAL:int = 10;
			private var baseTimer:int;
			private var t:Timer;
			private var dateFormatter:DateFormatter;
			
			/**
			 * @referenceComponent: the component that this menu will refer to for positioning itself
			 * @canvasView: the host view
			 * @optionsPanel: an initialised KSketch_Options (this has to be done in the canvas first because of the timebar)
			 * @ksketchInstance: The canvas's ksketch instance
			 */
			public function init(referenceComponent:UIComponent, canvasView:KSketch_CanvasView, optionsPanel:KSketch_Options, 
								 instructionsPanel:KSketch_InstructionsBox, savePanel:KSketch_SaveOptions, 
								 KSketchInstance:KSketch2, interactionControl:KInteractionControl, canvasControl:KCanvasInteractorManager,
							     feedback:KSketch_Feedback_Message):void
			{
				_referenceComponent = referenceComponent;
				_canvasOrigin = referenceComponent.localToGlobal(_canvasOrigin);
				_position = 1;
				
				_canvasView = canvasView;
				_KSketch = KSketchInstance;
				_interactionControl = interactionControl;
				_canvasControl = canvasControl;
				_options = optionsPanel;
				_instructionsBox = instructionsPanel;
				_feedback = feedback;
				_saveOptions = savePanel;
			}
			
			public function _initButtons():void
			{
				this.removeEventListener(FlexEvent.CREATION_COMPLETE, _initButtons);
				undoButton.init(KSketchAssets.texture_undo, KSketchAssets.texture_undo_down, false);
				undoButton.initSkin();
				redoButton.init(KSketchAssets.texture_redo, KSketchAssets.texture_redo_down, false);
				redoButton.initSkin();
				optionButton.init(KSketchAssets.texture_options, KSketchAssets.texture_options_down, false);
				optionButton.initSkin();
				connectButton.init(KSketchAssets.texture_connect, KSketchAssets.texture_connect_down, false);
				connectButton.initSkin();
				instructionsButton.init(KSketchAssets.texture_instructions, KSketchAssets.texture_instructions_down, false);
				instructionsButton.initSkin();
				
				if(_saveOptions)
				{
					exitButton.visible = true;
					exitButton.init(KSketchAssets.texture_prevScreen, KSketchAssets.texture_prevScreen_down, false);
					exitButton.initSkin();
				}
				
				eraserToggle.init(KSketchAssets.texture_eraser, KSketchAssets.texture_eraser_down, false);
				eraserToggle.initSkin();
				blackToggle.init(KSketchAssets.texture_blackPen, KSketchAssets.texture_blackPen_down, false);
				blackToggle.initSkin();
				redToggle.init(KSketchAssets.texture_redPen, KSketchAssets.texture_redPen_down, false);
				redToggle.initSkin();
				blueToggle.init(KSketchAssets.texture_bluePen, KSketchAssets.texture_bluePen_down, false);
				blueToggle.initSkin();
				greenToggle.init(KSketchAssets.texture_greenPen, KSketchAssets.texture_greenPen_down, false);
				greenToggle.initSkin();
				
				_setPen(blackToggle, true);
				
				resetTimer();
			}
			
			public function initInstructions():void
			{
				if(_canvasView.isNewSketch)
					instructionsButton.visible = false;
			}
			
			public function set position(value:int):void
			{
				_position = value;
				switch(_position)
				{
					case UP:
					case DOWN:
						buttonLayout.requestedColumnCount = -1;
						buttonLayout.requestedRowCount = 1;
						break;
					case LEFT:
					case RIGHT:
					default:
						buttonLayout.requestedColumnCount = 1;
						buttonLayout.requestedRowCount = -1;
						break;
				}
				
				dispatchEvent(new FlexEvent(FlexEvent.UPDATE_COMPLETE));
			}
			
			public function updateMenuDisplay():void
			{
				this.removeEventListener(FlexEvent.UPDATE_COMPLETE, updateMenuDisplay);
				
				if(_referenceComponent)
					_canvasOrigin = _referenceComponent.localToGlobal(ORIGIN);
				
				switch(_position)
				{ 
					case UP:
					default:
						x = _canvasOrigin.x + (_referenceComponent.width/2) - (width/2);
						y = _canvasOrigin.y + KSketchStyles.MENU_GAP;
						break;
					case DOWN:
						x = _canvasOrigin.x + (_referenceComponent.width/2) - (width/2);
						y = _canvasOrigin.y + _referenceComponent.height - height - KSketchStyles.MENU_GAP;
						break;
					case LEFT:
						x = _canvasOrigin.x + KSketchStyles.MENU_GAP;
						y = _canvasOrigin.y + (_referenceComponent.height/2) - (height/2);
						break;
					case RIGHT:
						x = _canvasOrigin.x + _referenceComponent.width - width - KSketchStyles.MENU_GAP;
						y = _canvasOrigin.y + (_referenceComponent.height/2) - (height/2);
						break;
				}
			}
			
			private function _setPen(button:KSketch_Toggle_Button, init:Boolean):void
			{
				KSketch_CanvasView.tracker.trackPageview( "/popupmenu/" + button.id);
				
				if(_selectedButton)
					_selectedButton.selected = false;
				
				button.selected = true;
				_selectedButton = button;
				var selectedTool:String = "";
				
				switch(_selectedButton)
				{
					case eraserToggle:
						KMultiTouchDrawInteractor.eraser = true;
						_canvasControl.lasso = false;
						selectedTool = "Eraser";
						break;
					case blackToggle:
						KMultiTouchDrawInteractor.eraser = false;
						_canvasControl.lasso = false;
						KDrawInteractor.penColor = KSketchStyles.BLACK_PEN;
						selectedTool = "Black Pen";
						break;
					case blueToggle:
						KMultiTouchDrawInteractor.eraser = false;
						_canvasControl.lasso = false;
						KDrawInteractor.penColor = KSketchStyles.BLUE_PEN;
						selectedTool = "Blue Pen";
						break;
					case redToggle:
						KMultiTouchDrawInteractor.eraser = false;
						_canvasControl.lasso = false;
						KDrawInteractor.penColor = KSketchStyles.RED_PEN;
						selectedTool = "Red Pen";
						break;
					case greenToggle:
						KMultiTouchDrawInteractor.eraser = false;
						_canvasControl.lasso = false;
						KDrawInteractor.penColor = KSketchStyles.GREEN_PEN;
						selectedTool = "Green Pen";
						break;
				}
				//LOG
				if(!init)
				{
					_KSketch.logCounter ++;
					var log:XML = <Action/>;
					var date:Date = new Date();
					log.@category = "Pop Up Menu";
					log.@type = "Set " + selectedTool;
					//trace("ACTION " + _KSketch.logCounter + ": Selected a " + selectedTool);
					KSketch2.log.appendChild(log);
				}
			}
			
			/**
			 * Clears the current document of every single content, without saving it.
			 */
			private function _clear():void
			{
				//LOG
				_KSketch.logCounter ++;
				var log:XML = <Action/>;
				var date:Date = new Date();
				log.@category = "Pop Up Menu";
				log.@type = "Set New Canvas";
				//trace("ACTION " + _KSketch.logCounter + ": Set up a new canvas");
				KSketch2.log.appendChild(log);
				
				KSketch_CanvasView.tracker.trackPageview( "/popupmenu/clearCanvas" );
				
				_saveOptions.returnToHome = false;
				if(_canvasView._interactionControl.hasUndo)
				{
					_saveOptions.open(_canvasView);
					PopUpManager.centerPopUp(_saveOptions);
				}
				else
				{
					KSketch_CanvasView.createNewSketch = true;
					_interactionControl.reset();
				}
			}
			
			/**
			 * Saves the current document to a file.
			 */
			private function _saveToFile():void
			{
				var docsDir:File = File.documentsDirectory;
				try
				{
					docsDir.browseForSave("Save As");
					docsDir.addEventListener(Event.SELECT, saveData);
				}
				catch (error:Error)
				{
					trace("Failed:", error.message);
				}
			}
			
			private function saveData(event:Event):void 
			{
				var newFile:File = event.target as File;
				
				var confirmSave:Boolean = true;
				var userData:Object = _canvasView.saveSketch(confirmSave);
				
				var finalFileName:String =  newFile.name;
				
				var objDoc:Object = KWebData.prepareSketchDocument(userData, finalFileName);
				objDoc.save = -1;
				objDoc.deleteFlag = 0;
				objDoc.version = 1;
				objDoc.originalVersion = 0;	
				objDoc.originalSketch = -1;
				objDoc.sketchId = "";
				
				var str:String = com.adobe.serialization.json.JSON.encode(objDoc);
				
				//save to file
				var stream:FileStream = new FileStream();
				stream.open(newFile, FileMode.WRITE);
				stream.writeUTFBytes(str);
				stream.close();
				
				//save to cache
				_canvasView.mobileControl.addSketchToList(objDoc, KFileControl.ADD_SAVE_CACHE);
				_canvasView.mobileControl.writeToCache(_canvasView.mobileControl.informationArr);
				_exit();
			}
			
			/**
			 * Triggers undo/redo action
			 */
			public function _undoRedoAction(action:Boolean):void
			{
				_canvasControl.doubleTapAction(action, _feedback);
			}
			
			/**
			 * Triggers exit
			 */
			public function _saveExit():void
			{
				//LOG
				_KSketch.logCounter ++;
				var log:XML = <Action/>;
				var date:Date = new Date();
				log.@category = "Pop Up Menu";
				log.@type = "Exit Canvas";
				//trace("ACTION " + _KSketch.logCounter + ": Exit canvas");
				KSketch2.log.appendChild(log);
				
				KSketch_CanvasView.tracker.trackPageview( "/popupmenu/exitCanvas" );
				
				_saveOptions.returnToHome = true;
				if(_canvasView._interactionControl.hasUndo)
				{
					_saveOptions.open(_canvasView);
					PopUpManager.centerPopUp(_saveOptions);
				}
				else
					_exit();
			}
			
			public function _exit():void
			{
				close();
				_canvasView.exit();
				KSketch_CanvasView.createNewSketch = false;
			}
			
			/**
			 * Opens the options dialog box
			 */
			private function _openOptions():void
			{
				//LOG
				_KSketch.logCounter ++;
				var log:XML = <Action/>;
				var date:Date = new Date();
				log.@category = "Pop Up Menu";
				log.@type = "Open Option Box";
				//trace("ACTION " + _KSketch.logCounter + ": Open option box");
				KSketch2.log.appendChild(log);
				
				KSketch_CanvasView.tracker.trackPageview( "/popupmenu/openOptions" );
				_options.open(_canvasView,true);
				PopUpManager.centerPopUp(_options);
			}
			
			/**
			 * Opens instructions message box
			 */
			private function _openInstructions():void
			{
				KSketch_CanvasView.tracker.trackPageview( "/popupmenu/openOptions" );
				_instructionsBox.open(_canvasView,true);
				PopUpManager.centerPopUp(_instructionsBox);
				_instructionsBox.x = 20; // or any other number
				_instructionsBox.y = 20; //whatever number. try tweaking it
			}
			
			/**
			 * Connects to the web service to send results to Synphne platform
			 */
			private function _openConnect():void
			{
				//LOG
				_KSketch.logCounter ++;
				var log:XML = <Action/>;
				var date:Date = new Date();
				log.@category = "Pop Up Menu";
				log.@type = "Connect to Synphne";
				//trace("ACTION " + _KSketch.logCounter + ": Connect to Synphne");
				KSketch2.log.appendChild(log);
			}
			
			/**
			 * Opens the save dialog box
			 */
			private function _openSaveOptions():void
			{
				_saveOptions.open(_canvasView);
				PopUpManager.centerPopUp(_saveOptions);
			}
			
			public function startTimer():void
			{
				t = new Timer(TIMER_INTERVAL);
				t.addEventListener(TimerEvent.TIMER, updateTimer);
				
				baseTimer = getTimer();
				t.start();
			}
			
			private function updateTimer(evt:TimerEvent):void {
				var d:Date = new Date(getTimer() - baseTimer);
				
				dateFormatter = new DateFormatter();
				dateFormatter.formatString = 'NN:SS'
				timerLabel.text = "Time: " + dateFormatter.format(d);
			}
			
			public function stopTimer():void
			{
				t.stop();
				t.removeEventListener(TimerEvent.TIMER, updateTimer);
			}
			
			public function resetTimer():void
			{
				timerLabel.text = "Time: 00:00";
			}
			
		]]>
	</fx:Script>
	
	<s:Group id="topContainer">
		<s:layout>
			<s:HorizontalLayout gap="80"/>
		</s:layout>
		
		<buttons:KSketch_Button
			id="instructionsButton"
			click="_openInstructions()"
			width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
			height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
			/>
		
		<s:Group>
			<s:filters>
				<s:DropShadowFilter 
					color="{KSketchStyles.CANVAS_SHADOW_COLOR}" angle="{KSketchStyles.CANVAS_SHADOW_ANGLE}"
					alpha="{KSketchStyles.CANVAS_SHADOW_ALPHA * 0.5}"
					strength="{KSketchStyles.CANVAS_SHADOW_STRENGTH}"
					blurX="{KSketchStyles.CANVAS_SHADOW_X_DISTANCE * 0.75}"
					blurY="{KSketchStyles.CANVAS_SHADOW_Y_DISTANCE * 0.75}"/>
			</s:filters>
			<s:Rect width="100%" height="100%" radiusX="{KSketchStyles.MENU_CORNER_RADIUS}" radiusY="{KSketchStyles.MENU_CORNER_RADIUS}">
				<s:fill>
					<s:SolidColor color="{KSketchStyles.MENU_BACKGROUND_COLOR}"/>
				</s:fill>
			</s:Rect>
			<s:Group id="buttonContainer">
				<s:layout>
					<s:TileLayout id="buttonLayout" requestedColumnCount="1" requestedRowCount="-1"
								  horizontalGap="{KSketchStyles.MENU_BUTTON_GAP}" verticalGap="{KSketchStyles.MENU_BUTTON_GAP}"
								  paddingLeft="{KSketchStyles.MENU_PADDING}" paddingRight="{KSketchStyles.MENU_PADDING}"
								  paddingBottom="{KSketchStyles.MENU_PADDING}" paddingTop="{KSketchStyles.MENU_PADDING}"/>
				</s:layout>
				
				<buttons:KSketch_Button
					includeInLayout="{!KSketch_CanvasView.isWeb}"
					click="_saveExit()"
					id="exitButton"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					visible="false"
					/>
				<buttons:KSketch_Button
					click="_undoRedoAction(true)"
					id="undoButton"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				<buttons:KSketch_Button
					click="_undoRedoAction(false)"
					id="redoButton"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				
				<!-- add in separator to the next button-->
				<s:Group>
					<s:layout> <s:HorizontalLayout gap="{KSketchStyles.POPUP_SEPARATOR_GAP}"/> </s:layout>
					<s:Group width="100%">
						<s:Line xFrom="0" xTo="0" yFrom="0" yTo="{KSketchStyles.POPUP_SEPARATOR_LINE}">
							<s:stroke>
								<s:SolidColorStroke color="0x000000" weight="2" caps="square"/>
							</s:stroke>
						</s:Line>
					</s:Group>
					<buttons:KSketch_Toggle_Button
						click="{_setPen(blackToggle, false)}"
						id="blackToggle"
						width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
						height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
						/>
				</s:Group>
				
				<buttons:KSketch_Toggle_Button
					click="{_setPen(redToggle, false)}"
					id="redToggle"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				<buttons:KSketch_Toggle_Button
					click="{_setPen(blueToggle, false)}"
					id="blueToggle"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				<buttons:KSketch_Toggle_Button
					click="{_setPen(greenToggle, false)}"
					id="greenToggle"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				<buttons:KSketch_Toggle_Button
					click="{_setPen(eraserToggle, false)}"
					id="eraserToggle"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
				
				<!-- add in separator to the next button-->
				<s:Group>
					<s:layout> <s:HorizontalLayout gap="{KSketchStyles.POPUP_SEPARATOR_GAP}"/> </s:layout>
					<s:Group width="100%">
						<s:Line xFrom="0" xTo="0" yFrom="0" yTo="{KSketchStyles.POPUP_SEPARATOR_LINE}">
							<s:stroke>
								<s:SolidColorStroke color="0x000000" weight="2" caps="square"/>
							</s:stroke>
						</s:Line>
					</s:Group>
					<buttons:KSketch_Button
						click="_openOptions()"
						id="optionButton"
						width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
						height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
						/>
				</s:Group>
				
				<buttons:KSketch_Button
					click="_openConnect()"
					id="connectButton"
					width="{KSketchStyles.TIMEBAR_BUTTON_WIDTH}"
					height="{KSketchStyles.TIMEBAR_BUTTON_HEIGHT}"
					/>
			</s:Group>
		</s:Group>
		<s:Label id="timerLabel" width="100" height="50" text="Time:" /> 
		
	</s:Group>
</s:SkinnablePopUpContainer>
