<?xml version="1.0" encoding="utf-8"?>
<!--
*Copyright 2010-2012 Singapore Management University
*Developed under a grant from the Singapore-MIT GAMBIT Game Lab

*This Source Code Form is subject to the terms of the
*Mozilla Public License, v. 2.0. If a copy of the MPL was
*not distributed with this file, You can obtain one at
*http://mozilla.org/MPL/2.0/.
-->
<s:Button xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" width="{height*2}" height="100%"
		 skinClass="views.canvas.components.timeBar.KTouchTimebarButtonSkin">
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import org.gestouch.events.GestureEvent;
			import org.gestouch.gestures.PanGesture;
			import org.gestouch.gestures.TapGesture;
			
			import sg.edu.smu.ksketch2.KSketch2;
			import sg.edu.smu.ksketch2.controls.widgets.KTimeControl;
			
			import views.canvas.KSketch_CanvasView;
			
			public static const LABEL_CURRENT_TIME:int = -1;
			public static const LABEL_MAX_TIME:int = 1;
			
			private const _PAN_SPEED_1:int = 1
			private const _PAN_SPEED_2:int = 3;
			private const _PAN_SPEED_3:int = 9;
			private const _PAN_SPEED_4:int = 15;
			private const _PAN_THRESHOLD_1:Number = 5;
			private const _PAN_THRESHOLD_2:Number = 8;
			private const _PAN_THRESHOLD_3:Number = 10;
			private const _STEP_THRESHOLD:Number = 7;
			
			private var _KSketch:KSketch2;
			private var _type:int;
			private var _timeControl:KTouchTimeControl;
		
			private var _panGesture:PanGesture;
			private var _tapGesture:TapGesture;
			
			private var _panVector:Point = new Point();
			private var _panSpeed:int = _PAN_SPEED_1;
			private var _prevOffset:Number = 1;
			private var _panOffset:Number = 0;
			
			private const _FILL1:uint = 0x000000;

			public function init(KSketchInstance:KSketch2, timeControl:KTouchTimeControl, type:int):void
			{
				_KSketch = KSketchInstance;
				_timeControl = timeControl;
				_type = type;
				
				_tapGesture = new TapGesture(this);
				_tapGesture.maxTapDuration = 200;
				_tapGesture.addEventListener(org.gestouch.events.GestureEvent.GESTURE_RECOGNIZED, _handleTap);
				
				_panGesture = new PanGesture(this);
				_panGesture.addEventListener(org.gestouch.events.GestureEvent.GESTURE_CHANGED, _panUpdate);
				_panGesture.addEventListener(org.gestouch.events.GestureEvent.GESTURE_ENDED, _panEnd);
				
				
				
				var iconGraphics:Graphics = (skin as KTouchTimebarButtonSkin).iconGraphics.graphics
				
				if(_type == LABEL_CURRENT_TIME)
				{
					iconGraphics.beginFill(KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_BUTTON_BLEND);
					iconGraphics.moveTo(width*0.5,height*0.5);
					iconGraphics.lineTo(width*0.727,height*0.75);
					iconGraphics.lineTo(width*0.727,height*0.25);
					iconGraphics.lineTo(width*0.5,height*0.5);
					iconGraphics.endFill();
										
					iconGraphics.beginFill(KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_BUTTON_BLEND);
					iconGraphics.moveTo(width*0.2181,height*0.5);
					iconGraphics.lineTo(width*0.4454,height*0.25);
					iconGraphics.lineTo(width*0.4454,height*0.75);
					iconGraphics.lineTo(width*0.2181,height*0.5);
					iconGraphics.endFill();

					iconGraphics.lineStyle(1, KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_DIVIDER_BLEND);
					iconGraphics.moveTo(width,height*0.1);
					iconGraphics.lineTo(width,height*0.9);
				}
				else
				{
					iconGraphics.beginFill(KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_BUTTON_BLEND);
					iconGraphics.moveTo(width*0.5,height*0.5);
					iconGraphics.lineTo(width*0.2727,height*0.25);
					iconGraphics.lineTo(width*0.2727,height*0.75);
					iconGraphics.lineTo(width*0.5,height*0.5);
					iconGraphics.endFill();
					
					iconGraphics.beginFill(KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_BUTTON_BLEND);
					iconGraphics.moveTo(width*0.7818,height*0.5);
					iconGraphics.lineTo(width*0.5545,height*0.75);
					iconGraphics.lineTo(width*0.5545,height*0.25);
					iconGraphics.lineTo(width*0.7818,height*0.5);
					iconGraphics.endFill();
					
					iconGraphics.lineStyle(1, KSketch_CanvasView.CANVAS_BUTTON_COLOR, KSketch_CanvasView.CANVAS_DIVIDER_BLEND);
					iconGraphics.moveTo(1,height*0.1);
					iconGraphics.lineTo(1,height*0.9);
				}
			}
			
			/**
			 * Tap handler to handle tapping to advance/roll back frames
			 */
			private function _handleTap(event:org.gestouch.events.GestureEvent):void
			{
				_timeControl.jumpInDirection(_type)
			}
			
			private function _panUpdate(event:org.gestouch.events.GestureEvent):void
			{
				updateSlider(_panGesture.offsetX, _panGesture.offsetY);
				_timeControl.floatingLabel.showMessage(_timeControl.time);
			}
			
			private function _panEnd(event:org.gestouch.events.GestureEvent):void
			{
				resetSliderInteraction();
			}
			
			/**
			 * update slider with offsetX, subjected to speed changes
			 */
			public function updateSlider(offsetX:Number, offsetY:Number):void
			{
				//Changed direction, have to reset all pan gesture calibrations till now.
				if((_prevOffset * offsetX) < 0)
					resetSliderInteraction();
				
				_panVector.x = offsetX;
				_panVector.y = offsetY;
				
				var absOffset:Number = _panVector.length;
				
				//Pan Offset is the absolute distance moved during a pan gesture
				//Need to update to see how far this pan has moved.
				_panOffset += absOffset;
				
				//Speed calibration according to how far the pan gesture moved.
				if( absOffset <= _PAN_THRESHOLD_1)
					_panSpeed = _PAN_SPEED_1;
				else if(absOffset <= _PAN_THRESHOLD_2)
					_panSpeed = _PAN_SPEED_2;
				else if(absOffset <= _PAN_THRESHOLD_3)
					_panSpeed = _PAN_SPEED_3 * (_timeControl.maximum/KTimeControl.DEFAULT_MAX_TIME);
				else
					_panSpeed = absOffset * (_timeControl.maximum/KTimeControl.DEFAULT_MAX_TIME);
				
				//Update the time according to the direction of the pan.
				//Advance if it's towards the right
				//Roll back if it's towards the left.
				if(_panOffset > _STEP_THRESHOLD)
				{				
					if(0 < offsetX)
						_timeControl.time = _timeControl.time + (_panSpeed*KSketch2.ANIMATION_INTERVAL);
					else if(offsetX < 0)
						_timeControl.time = _timeControl.time - (_panSpeed*KSketch2.ANIMATION_INTERVAL);
					
					_panOffset = 0;
				}
				
				//Save the current offset value, will need this thing to check for
				//change in direction in the next update event
				_prevOffset =  offsetX;
			}
			
			/**
			 * For resetting slider interaction values;
			 */
			public function resetSliderInteraction():void
			{
				_prevOffset = 1;
				_panOffset = 0;
				_panSpeed = _PAN_SPEED_1;
			}
			
			public static function toTimeCode(milliseconds:Number):String
			{
				var seconds:int = Math.floor((milliseconds/1000));
				var strSeconds:String = seconds.toString();
				if(seconds < 10)
					strSeconds = "0" + strSeconds;
				
				
				var remainingMilliseconds:int = (milliseconds%1000)/10;
				var strMilliseconds:String = remainingMilliseconds.toString();
				strMilliseconds = strMilliseconds.charAt(0) + strMilliseconds.charAt(1);
				
				if(remainingMilliseconds < 10)
					strMilliseconds = "0" + strMilliseconds;
				
				var timeCode:String = strSeconds + ':' + strMilliseconds;
				return timeCode;
			}
		]]>
	</fx:Script>
</s:Button>